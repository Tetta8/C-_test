# まとめ
![まとめ](https://user-images.githubusercontent.com/61077860/83329087-3e40a300-a2c2-11ea-8612-5c45d7e2cf2b.png)

![まとめ2](https://user-images.githubusercontent.com/61077860/83329117-852e9880-a2c2-11ea-951d-cabf3fe96d6a.png)


# 具象クラス
値を表すデータメンバをもつ、単純な構造のクラスを具象クラスという。
具象クラスはオブジェクトのコピーが単純に行える。

※オブジェクト外部の資源にアクセスするクラスや仮想メンバ関数をもつクラス等は、具象クラスとはなりません。

## コピーコンストラクタ
オブジェクトの初期化時に同一のクラスオブジェクトで初期化処理を行うこと。  
オブジェクトのデータメンバの値は全てコピーされる。

## イミュータブルなオブジェクト
イミュータブル(オブジェクトの状態が変化しないもの)のオブジェクトは以下のように宣言する。
```
const クラス名　オブジェクト名();
```

イミュータブルなオブジェクトは通常のメンバ関数を使うことで、状態が変化する可能性がある為、メンバ関数を使用できないよになっている。  
※メンバ関数の処理内容をコンパイラで判定できない為

その為、クラスを定義するときに***const メンバ関数***として定義する必要がある。
クラスの使われ方は、クラス設計者は判断できないので、データメンバを変更しないメンバ関数は`必ずconst メンバ関数`として定義するべきである。

### mutableメンバ
イミュータブルなオブジェクトに対して例外的に変更できるデータメンバを作ることができる。  
そのメンバを*mutebleメンバ*と言う。
以下のように宣言をする。
```
mutable 型名 変数名；
```

## thisとは
*this*は対象ののオブジェクトを指すポインタである。 
よって、以下は対象オブジェクトをコピーすることになる。
```
クラス型　オブジェクト名 = *this;
```

## 戻り値
戻り値には以下のルールがある。
※以下のルールのみではない
 - 配列を指定して、**返すことはできない**。
 - クラス型のオブジェクトを指定して、**返すことができる**。
 - クラスのコンストラクタを設定することで、一時的なオブジェクトを作成して、**返すことができる**。

 ## 文字列ストリーム
 文字列の作成の為のストリーム。
 ヘッダファイル
 ```
 #include<sstream>
 ```

### 文字列ストリームの種類
 - ostringstream：文字列への出力を行うストリーム
 - istringstream：文字列からの入力を行うストリーム
 - stringstream:文字列への入出力を行うストリーム

### ストリームとは
連続したデータを「流れるもの」として、捉え、そのデータの入出力(送受信)を扱うこと。
操作や抽象データ型を指す。

[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))

## has-Aの関係
あるクラスがその一部分として別のクラスを持つこと。

## コンポジットなオブジェクトで内部のクラスを初期化する方法
**コンストラクタ初期化子**を使うことで初期化を行うことができる。
```
クラス名::メンバ関数名(引数):オブジェクト(初期化){
    // 処理
}
```

クラスで定義されたオブジェクトの初期化をコンストラクタ内で実行仕様とする場合は、
**初期化ではなく、代入**となる。

### 初期化と代入の違い
代入を行う場合に以下の問題がある。
 - 部分オブジェクトが生成される際に、デフォルトコンストラクタで<<初期化>>される。  
 そのクラスにデフォルトコンストラクタが無ければコンパイルエラーとなる。
 - 生成されて初期化された部分オブジェクトに対する<<代入>>が行われる。  
 メンバに対する値の設定が初期化・代入の2段階となり、処理時間がかかる。

#### 初期化の振る舞い
 1. オブジェクトが生成される際に、部分オブジェクトが生成される。
 2. 部分オブジェクトのデフォルトコンストラクタが呼び出されれ、初期化される。

#### 代入の振る舞い
※初期化の振る舞いに加えて
 3. 部分オブジェクトに代入するための一時オブジェクトが作られる。
 4. 部分オブジェクトに代入される。

## 静的メンバ

### 静的データメンバ
同一のクラスから生成される全てのオブジェクトで共有すべき情報を保持できるデータメンバ。  
■宣言：*static*をつける。
```
static int counter;
```
■定義：*static*をつけない
```
int IdNo::counter = 0;
```
■アクセス方法
```
クラス名::データメンバ名    //推奨
オブジェクト.データメンバ名 //使わない方が良い　※クラス共通のデータメンバの為
```

#### ルール
 - 静的データメンバの初期化しは、**クラス定義の外のデータメンバの定義で与える**。
 - 静的データメンバが、constの場合に限り**クラス定義の中のデータメンバの宣言で与えてよい**。
 - 静的データメンバにアクセスする場合は***クラス名::データメンバ名***でアクセスすることが推奨される

### 静的メンバ関数
同一のクラスから生成される全てオブジェクトに関わる手続きや、個々のオブジェクトの状態とは無関係な手続き。
  
■宣言：*static*をつける。
```
static int get_max_id();
```

■定義：*static*をつけない
```
int IdNo::get_max_id(){};
```
■アクセス方法
```
クラス名::メンバ関数名    //推奨
オブジェクト.メンバ関数名 //使わない方が良い ※クラス共通のメンバ関数の為
```

### ルール
 - 静的データメンバの定義とそれをアクセスする全てのメンバ関数の定義は、単一のソースファイルにまとめなければならない。
 ※静的データメンバの初期化は「それを定義するソースファイル中で初めて利用される時点までに完了する」ことになっている為、他ファイルに記載したソースコードからアクセスすると初期化されていない可能性がある。
 - 同一クラスの非静的データメンバをアクセスすることはできない。
 - 同一クラスの非静的メンバ関数*f*を*f(…)*として呼び出すことはできない。
 - *const*メンバ関数にはなれない。
 - thisポインタをもたない。
 - 同一名のメンバ関数を定義する多重定義は、静的メンバ関数と非静的メンバ関数にまたがって行える。
  
