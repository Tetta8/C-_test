# 変換関数と演算子関数
組込み型と同じような感覚でクラス型のオブジェクトを扱えるように、+や=や++などの演算子の挙動を自由に定義できる。  
演算子の挙動を定義する為の演算子の多重定義を活用する。

## 前置形式、後置形式
```
class C{
publice:
    Type operator++();      // 前置増分演算子
    Type operator++(int);   // 後置増分演算子
};
```

各演算子の戻り値
 - 前置演算子・・・*C&* 型  
    前置演算子は、その呼び出し式が左辺値式となるようにするために*C&* 型の **this* を返却する 
 - 後置演算子・・・*C*型

# 真理値クラス

## 設計方針
 1. 偽をFalse、真をTrueの列挙子で表す。これら以外の値は持たない。
 2. クラスの内部では、Falseを0で表し、Trueを1で表す。
 3. int型の値と相互に変換できるようにする。int型として値を取り出す際は、Falseは0として、Trueは1とする。int型の値が代入される際は、0で有ればFalseとして、0以外の値であれば（たとえ1ではなくても）Trueとする。
 4. 文字列表現"False"あるいは"True"として取り出せる
 5. 出力ストリームに対する挿入子<<によって、文字列"False"あるいは"True"として出力できる。

## 変換コンストラクタ
単一の実引数で呼び出せるコンストラクタは、実引数型をクラス型に変換する働きをするため、変換コンストラクタと呼ばれる。

```
Boolean x = 1;  // 初期化:Boolean x(1)
Boolean y;
y = 0;          // 代入：y = Boolena(0);
```

## 変換関数
クラスのクラス型を実引数型に変換して戻り値を返す関数を変換関数という。

```
operator int() const{return v;}
```

### 変換関数のキャスト方法
 1. 関数的記法"Type(式)"によるキャスト
 2. 静的キャスト演算子"static_cast＜Type＞(式)"によるconst char*へのキャスト

## ユーザ定義変換
**変換コンストラクタ（実引数⇒クラス型）**と**変換関数（クラス型⇒実引数）**を揃えて**ユーザ定義変換**という。

## ヘッダファイルのクラス定義外に非メンバ関数を定義する場合
*inline* または、 *static* を使って内部結合を持たせる必要がある。  
⇒なぜなら、外部結合の状態で、複数ファイルでヘッダファイルをインクルードするとクラス固有のメンバ関数として、認識されないため、重複定義となりリンクエラーが発生する。

## フレンド関数
フレンド関数になれるのはクラスの外部で定義される通常の関数＝非メンバ関数か、他のクラスに所属するメンバ関数である。

メンバ関数との違い

### メンバ関数
メンバ関数は、クラスに所属する為、2つ以上のクラスのメンバ関数になることは無い。
また、クラスオブジェクトに対して起動されたメンバ関数は、対象のオブジェクトを指すthisポインタを内部に持っている。

### フレンド関数
基本的な振る舞いは非メンバ関数と同じで、そのクラスのオブジェクトに対して起動されるわけではない。
その為、ドット演算子を使ったアクセスはできない。  
thisポインタも持たない。
しかし、クラス内部にアクセスできる許可が与えられてるため、非公開のデータにアクセスできる。

## 2項に対する演算子の関数
2項を対象にする場合にメンバ関数とすると、計算式の記載順によってはコンパイルエラーとなってしまう。
なので、非メンバ関数で実現する必要がある。

## const 参照引数の特徴
 - 引数の受け渡しにおいてコピーコンストラクタが起動されないようになる
 - int型やdouble型等の定数値を受け取れるようになる

### コピーコンストラクタの弊害
コピーコンストラクタは、コピー元のオブジェクトの情報を一時的に保持する為の一時オブジェクトが生成される。
クラスのサイズが大きい場合い一時オブジェクトを生成すると、メモリの使用量と演算時間の増加に繋がってしまう。
参照渡しなら別名をつけるだけなので、コピーコンストラクタが使われない為、処理負荷を下げることができる。


